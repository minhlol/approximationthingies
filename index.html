<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monkeypox SEIQR-SEI Model Visualization</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü¶†</text></svg>">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ü¶† Monkeypox SEIQR-SEI Model Visualization</h1>
        <div class="subtitle">Two-Population Model with Continuous Correction & Endemic Rodent Reservoir</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="yearSelect">üìÖ Year:</label>
                <select id="yearSelect" onchange="filterData()">
                    <option value="all">All Years</option>
                    <option value="2022">2022</option>
                    <option value="2023">2023</option>
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                </select>
            </div>
            <div class="control-group">
                <label for="viewSelect">üìä View:</label>
                <select id="viewSelect" onchange="changeView()">
                    <option value="comparison">Model vs Observed</option>
                    <option value="human">Human Compartments</option>
                    <option value="rodent">Rodent Compartments</option>
                </select>
            </div>
            <div class="control-group">
                <label for="scaleSelect">üìè Y-Scale:</label>
                <select id="scaleSelect" onchange="updateScale()">
                    <option value="linear">Linear</option>
                    <option value="log">Logarithmic</option>
                </select>
            </div>
        </div>
        
        <div class="chart-container">
            <canvas id="seirChart"></canvas>
        </div>
        
        <div class="stats" id="statsContainer"></div>
        
        <div class="architecture-section">
            <h2>üìê Model Architecture & Flow</h2>
            
            <h3>Model Equations</h3>
            
            <h4 style="color: #555; font-size: 1.2em; margin-top: 20px;">Human Compartments (SEIQR)</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0;">
                <p style="margin-bottom: 10px;">Force of infection:</p>
                <p style="font-size: 1.1em; margin: 10px 0;">$$\lambda_h = \frac{(\beta_1 \cdot I_r + \beta_2 \cdot I_h) \cdot S_h}{N_h}$$</p>
                
                <p style="margin: 20px 0 10px 0;">Differential equations:</p>
                <div style="font-size: 1.1em; line-height: 2.2;">
                    $$\frac{dS_h}{dt} = \theta_h - \lambda_h - \mu_h \cdot S_h + \phi \cdot Q_h$$
                    $$\frac{dE_h}{dt} = \lambda_h - (\alpha_1 + \alpha_2 + \mu_h) \cdot E_h$$
                    $$\frac{dI_h}{dt} = \alpha_1 \cdot E_h - (\mu_h + \delta_h + \nu) \cdot I_h$$
                    $$\frac{dQ_h}{dt} = \alpha_2 \cdot E_h - (\phi + \tau + \delta_h + \mu_h) \cdot Q_h$$
                    $$\frac{dR_h}{dt} = \nu \cdot I_h + \tau \cdot Q_h - \mu_h \cdot R_h$$
                </div>
            </div>
            
            <h4 style="color: #555; font-size: 1.2em; margin-top: 30px;">Rodent Compartments (SEI)</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0;">
                <p style="margin-bottom: 10px;">Force of infection:</p>
                <p style="font-size: 1.1em; margin: 10px 0;">$$\lambda_r = \frac{\beta_3 \cdot S_r \cdot I_r}{N_r}$$</p>
                
                <p style="margin: 20px 0 10px 0;">Differential equations:</p>
                <div style="font-size: 1.1em; line-height: 2.2;">
                    $$\frac{dS_r}{dt} = \theta_r - \lambda_r - \mu_r \cdot S_r$$
                    $$\frac{dE_r}{dt} = \lambda_r - (\mu_r + \alpha_3) \cdot E_r$$
                    $$\frac{dI_r}{dt} = \alpha_3 \cdot E_r - (\mu_r + \delta_r) \cdot I_r$$
                </div>
                
                <p style="margin: 20px 0 10px 0; font-size: 0.95em;">With population homeostasis:</p>
                <div style="font-size: 1em; line-height: 1.8; padding-left: 20px;">
                    $$\text{If } N_{r,\text{current}} < 0.95 \times N_r\text{: } S_r \mathrel{+}= (N_r - N_{r,\text{current}}) \times 0.01$$
                    $$\text{Endemic equilibrium: } E_r \approx 3, \; I_r \approx 8$$
                </div>
            </div>
            
            <h4 style="color: #555; font-size: 1.2em; margin-top: 30px;">Numerical Integration (RK4)</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0 40px 0;">
                <div style="font-size: 1.1em; line-height: 2.2;">
                    $$k_1 = f(t, y)$$
                    $$k_2 = f(t + \frac{dt}{2}, y + k_1 \cdot \frac{dt}{2})$$
                    $$k_3 = f(t + \frac{dt}{2}, y + k_2 \cdot \frac{dt}{2})$$
                    $$k_4 = f(t + dt, y + k_3 \cdot dt)$$
                    $$y_{n+1} = y_n + \frac{k_1 + 2k_2 + 2k_3 + k_4}{6} \cdot dt$$
                </div>
                <p style="margin-top: 15px; font-size: 0.95em;">Steps per day: 10 (dt = 0.1 day)</p>
            </div>
            
            <h3>System Overview</h3>
            <div class="diagram-description">
                Complete pipeline showing data flow through processing stages to output generation.
            </div>
            <div class="mermaid">
graph TB
    Start(["üöÄ Start"])
    InputTitle["üì• Data Input"]
    ModelTitle["üß¨ Three-Stage Modeling"]
    ForecastTitle["üîÆ Forecasting"]
    OutputTitle["üíæ Output"]
    
    subgraph Input[" "]
        direction TB
        A1["Load Data<br/>CSV"]
        A2["Moving Averages<br/>MA7 & MA21"]
        A3["Outbreak Detection"]
        
        A1 --> A2
        A2 --> A3
    end
    
    subgraph Model[" "]
        direction TB
        B1["üìà Stage 1<br/>Smoothing"]
        B2["üë• Stage 2<br/>SEIQR"]
        B3["üêÄ Stage 3<br/>SEIR"]
        B4["üìä Validation"]
        
        B1 --> B2
        B2 --> B3
        B3 --> B4
    end
    
    subgraph Forecast[" "]
        direction TB
        C1["Generate<br/>21-day"]
        C2["Trend Check"]
        
        C1 --> C2
    end
    
    subgraph Output[" "]
        direction TB
        D1["fitted.csv"]
        D2["prediction.csv"]
        D3["index.html"]
        
        D1 --> D3
        D2 --> D3
    end
    
    InputTitle -.-> Input
    ModelTitle -.-> Model
    ForecastTitle -.-> Forecast
    OutputTitle -.-> Output
    
    Start --> Input
    Input --> Model
    Model --> Forecast
    Forecast --> Output
    Output --> End(["‚úÖ Complete"])
    
    C2 -.->|Refine| B3
    
    style InputTitle fill:#1976d2,stroke:#1976d2,color:#fff,stroke-width:2px
    style ModelTitle fill:#f57c00,stroke:#f57c00,color:#fff,stroke-width:2px
    style ForecastTitle fill:#7b1fa2,stroke:#7b1fa2,color:#fff,stroke-width:2px
    style OutputTitle fill:#388e3c,stroke:#388e3c,color:#fff,stroke-width:2px
    style Input fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style Model fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Forecast fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style Output fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style Start fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style End fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
            </div>
            
            <h3>Continuous Correction Integration Loop</h3>
            <div class="diagram-description">
                RK4 integration with continuous correction targeting 4√ó observed values to account for underreporting. Dynamic Œ≤ parameters adjusted per outbreak period.
            </div>
            <div class="mermaid">
graph LR
    InitTitle["üé≤ Initialization"]
    LoopTitle["üîÑ Daily Integration Loop"]
    PostTitle["‚ú® Post-Processing"]
    
    subgraph Init[" "]
        direction TB
        InitH["üë• Human State<br/>S,E,I,Q,R"]
        InitR["üêÄ Rodent State<br/>S,E,I"]
    end
    
    subgraph Loop[" "]
        direction TB
        CheckOB["üîç Check Outbreak?"]
        CheckOB --> DynBeta["‚öôÔ∏è Dynamic Œ≤<br/>or Baseline"]
        DynBeta --> Correct["üéØ Correction<br/>25% rate ‚Üí 4√óobs"]
        Correct --> RK4Int["‚öôÔ∏è RK4<br/>10 steps/day"]
        RK4Int --> HomeoR["‚ôªÔ∏è Rodent<br/>Homeostasis"]
    end
    
    subgraph Post[" "]
        direction TB
        Smooth1["üìä Spline<br/>window-5"]
        Smooth1 --> Smooth2["üìä Spline<br/>window-3"]
    end
    
    InitTitle -.-> Init
    LoopTitle -.-> Loop
    PostTitle -.-> Post
    
    Init --> Loop
    Loop -.->|1288 days| Loop
    Loop --> Post
    
    style InitTitle fill:#0077cc,stroke:#0077cc,color:#fff,stroke-width:2px
    style LoopTitle fill:#ff9900,stroke:#ff9900,color:#fff,stroke-width:2px
    style PostTitle fill:#cc0077,stroke:#cc0077,color:#fff,stroke-width:2px
    style Init fill:#e1f5ff,stroke:#0077cc,stroke-width:2px
    style Loop fill:#fff4e1,stroke:#ff9900,stroke-width:2px
    style Post fill:#ffe1f5,stroke:#cc0077,stroke-width:2px
            </div>
            
            <h3>SEIQR-SEI Compartmental Structure</h3>
            <div class="diagram-description">
                Two-population epidemic model with human SEIQR compartments and rodent SEI reservoir. Cross-species zoonotic spillover (Œ≤‚ÇÅ) shown with dashed arrows. Endemic equilibrium: E_r‚âà3, I_r‚âà8.
            </div>
            <div class="mermaid">
graph TB
    HumanTitle["üë• Human Population: SEIQR Model"]
    RodentTitle["üêÄ Rodent Reservoir: SEI Model"]
    
    subgraph Human[" "]
        direction LR
        Sh["<i>S<sub>h</sub></i><br/>Susceptible"]
        Eh["<i>E<sub>h</sub></i><br/>Exposed"]
        Ih["<i>I<sub>h</sub></i><br/>Infectious"]
        Qh["<i>Q<sub>h</sub></i><br/>Quarantined"]
        Rh["<i>R<sub>h</sub></i><br/>Recovered"]
        
        Sh -->|<i>Œª<sub>h</sub></i>| Eh
        Eh -->|<i>Œ±</i>‚ÇÅ| Ih
        Eh -->|<i>Œ±</i>‚ÇÇ| Qh
        Ih -->|<i>ŒΩ</i>| Rh
        Qh -->|<i>œÑ</i>| Rh
        Qh -->|<i>œÜ</i>| Sh
    end
    
    subgraph Rodent[" "]
        direction LR
        Sr["<i>S<sub>r</sub></i><br/>Susceptible"]
        Er["<i>E<sub>r</sub></i><br/>Exposed"]
        Ir["<i>I<sub>r</sub></i><br/>Infectious"]
        
        Sr -->|<i>Œª<sub>r</sub></i>| Er
        Er -->|<i>Œ±</i>‚ÇÉ| Ir
        Sr -.->|Immigration| Sr
        Ir -.->|Replenishment| Ir
    end
    
    HumanTitle -.-> Human
    RodentTitle -.-> Rodent
    
    Ir ==>|<i>Œ≤</i>‚ÇÅ Zoonotic| Sh
    Ih ==>|<i>Œ≤</i>‚ÇÇ H2H| Sh
    
    style HumanTitle fill:#1976d2,stroke:#1976d2,color:#fff,stroke-width:2px
    style RodentTitle fill:#c2185b,stroke:#c2185b,color:#fff,stroke-width:2px
    style Human fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style Rodent fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style Sh fill:#c8e6c9
    style Eh fill:#fff9c4
    style Ih fill:#ffccbc
    style Qh fill:#ff8a65
    style Rh fill:#b39ddb
    style Sr fill:#c8e6c9
    style Er fill:#fff9c4
    style Ir fill:#ffccbc
            </div>
            
            <h3>21-Day Forecast Generation</h3>
            <div class="diagram-description">
                Adaptive forecasting algorithm that selects between trajectory-based and mechanistic predictions based on epidemic phase.
            </div>
            <div class="mermaid">
graph TB
    Start(["üîÅ For Each Day<br/>in Historical Data"])
    Start --> Trend{"üìä Analyze 7-Day Trend<br/>Growth Rate"}
    
    Trend -->|"üìà <i>Trend ‚â• ‚àí2</i><br/>Growth/Stable"| PathA["üéØ Trajectory Method<br/>High confidence in model"]
    Trend -->|"üìâ <i>Trend < ‚àí2</i><br/>Rapid Decline"| PathB["‚öôÔ∏è Mechanistic Method<br/>SEIQR-SEIR dynamics"]
    
    PathA --> Lookup["üîç Lookup Future<br/>Model prediction at day+21"]
    Lookup --> Blend["üé® Blend Values<br/>90% future + 10% current<br/>Smooth transition"]
    Blend --> Output
    
    PathB --> RodentCheck{"üêÄ Check Reservoir<br/><i>I<sub>r</sub></i> > 0.01?"}
    RodentCheck -->|"‚úÖ Yes<br/>Active reservoir"| FullSim["üî¨ Full Two-Population<br/>With <i>Œ≤</i>‚ÇÅ spillover term<br/>Cross-species coupling"]
    RodentCheck -->|"‚ùå No<br/>Negligible reservoir"| SimpleSim["üë• Human-Only Model<br/>No zoonotic forcing<br/>Epidemic fadeout"]
    
    FullSim --> Integrate["‚öôÔ∏è RK4 Integration<br/>21 days √ó 10 steps/day<br/>Homeostasis maintained"]
    SimpleSim --> Integrate
    Integrate --> Output
    
    Output["üíæ Store Forecast<br/>at day+21 index"]
    Output --> Continue{"‚ùì More Days?"}
    Continue -->|"Yes"| Start
    Continue -->|"No"| Done(["‚úÖ Forecasting Complete<br/>All points processed"])
    
    style PathA fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style PathB fill:#ffccbc,stroke:#d84315,stroke-width:2px
    style FullSim fill:#fff9c4
    style SimpleSim fill:#e1bee7
    style Integrate fill:#b3e5fc
    style Start fill:#f0f0f0
    style Done fill:#c8e6c9
            </div>
            
            <h3>Key Parameters</h3>
            <div class="diagram-description">
                Parameter dependencies and relationships showing how transmission, progression, and control rates interact within the two-population model.
            </div>
            <div class="mermaid">
graph TB
    subgraph Pop["üìä Population Structure"]
        NH["<i>N<sub>h</sub></i>=1M<br/>Human pop"]
        NR["<i>N<sub>r</sub></i>=100K<br/>Rodent pop"]
        Target["<i>I<sub>r</sub></i>=1.5%<br/>Endemic"]
    end
    
    subgraph Trans["üîÄ Transmission Rates"]
        B1["<i>Œ≤</i>‚ÇÅ=0.00008<br/>üêÄ‚Üíüë§"]
        B2["<i>Œ≤</i>‚ÇÇ=0.00012<br/>üë§‚Üíüë§"]
        B3["<i>Œ≤</i>‚ÇÉ=0.0003<br/>üêÄ‚ÜíüêÄ"]
    end
    
    subgraph FOI["‚ö° Force of Infection"]
        LambdaH["<i>Œª<sub>h</sub></i><br/>Human force"]
        LambdaR["<i>Œª<sub>r</sub></i><br/>Rodent force"]
    end
    
    subgraph Prog["‚è±Ô∏è Disease Progression"]
        A1["<i>Œ±</i>‚ÇÅ=0.143<br/><i>E<sub>h</sub></i>‚Üí<i>I<sub>h</sub></i>"]
        A2["<i>Œ±</i>‚ÇÇ=0.067<br/><i>E<sub>h</sub></i>‚Üí<i>Q<sub>h</sub></i>"]
        A3["<i>Œ±</i>‚ÇÉ=0.20<br/><i>E<sub>r</sub></i>‚Üí<i>I<sub>r</sub></i>"]
        Branching["Detection<br/>32%"]
    end
    
    subgraph Rec["üè• Recovery & Control"]
        Nu["<i>ŒΩ</i>=0.067<br/><i>I<sub>h</sub></i>‚Üí<i>R<sub>h</sub></i>"]
        Tau["<i>œÑ</i>=0.143<br/><i>Q<sub>h</sub></i>‚Üí<i>R<sub>h</sub></i>"]
        Phi["<i>œÜ</i>=0.20<br/><i>Q<sub>h</sub></i>‚Üí<i>S<sub>h</sub></i>"]
        IsolationBenefit["<i>œÑ</i>><i>ŒΩ</i><br/>Faster"]
    end
    
    subgraph Death["‚ö†Ô∏è Mortality & Turnover"]
        DH["<i>Œ¥<sub>h</sub></i> CFR"]
        DR["<i>Œ¥<sub>r</sub></i> death"]
        MuH["<i>Œº<sub>h</sub></i> natural"]
        MuR["<i>Œº<sub>r</sub></i> natural"]
        ThetaH["<i>Œ∏<sub>h</sub></i> birth"]
        ThetaR["<i>Œ∏<sub>r</sub></i> birth"]
    end
    
    %% Relationships between parameter groups
    NH --> LambdaH
    NR --> LambdaR
    B1 --> LambdaH
    B2 --> LambdaH
    B3 --> LambdaR
    
    LambdaH -.->|"Drives <i>E<sub>h</sub></i>"| Prog
    LambdaR -.->|"Drives <i>E<sub>r</sub></i>"| Prog
    
    A1 -.-> Nu
    A2 -.-> Tau
    A2 -.-> Phi
    
    Target -.->|"Threshold"| B3
    NR -.->|"Scale"| Target
    
    ThetaH -.-> NH
    ThetaR -.-> NR
    MuH -.-> NH
    MuR -.-> NR
    
    Branching -.->|"Splitting"| A1
    Branching -.->|"Splitting"| A2
    IsolationBenefit -.->|"Compare"| Nu
    IsolationBenefit -.->|"Compare"| Tau
    
    style Pop fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Trans fill:#ffebee,stroke:#c62828,stroke-width:3px
    style FOI fill:#e1f5fe,stroke:#01579b,stroke-width:3px
    style Prog fill:#f3e5f5,stroke:#6a1b9a,stroke-width:3px
    style Rec fill:#e8f5e9,stroke:#2e7d32,stroke-width:3px
    style Death fill:#fafafa,stroke:#616161,stroke-width:2px
    style LambdaH fill:#b3e5fc,stroke:#0277bd,stroke-width:2px
    style LambdaR fill:#b3e5fc,stroke:#0277bd,stroke-width:2px
    style Branching fill:#ce93d8,stroke:#6a1b9a,stroke-width:2px
    style IsolationBenefit fill:#a5d6a7,stroke:#2e7d32,stroke-width:2px
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid with KaTeX support
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis',
                padding: 20,
                diagramPadding: 20,
                nodeSpacing: 50,
                rankSpacing: 50
            },
            themeVariables: {
                fontSize: '18px',
                fontFamily: 'Segoe UI, Arial, sans-serif',
                edgeLabelBackground: '#ffffff',
                lineColor: '#666',
                primaryColor: '#f8f9fa',
                primaryTextColor: '#333',
                primaryBorderColor: '#666',
                secondaryColor: '#fff',
                tertiaryColor: '#f8f9fa'
            },
            katex: {
                enabled: true
            }
        });
        
        // Add zoom and pan functionality to all mermaid diagrams
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for mermaid to fully render all diagrams
            setTimeout(() => {
                const mermaidContainers = document.querySelectorAll('.mermaid');
                
                mermaidContainers.forEach((container, index) => {
                    // Wait a bit more for complex diagrams
                    setTimeout(() => {
                        const svg = container.querySelector('svg');
                        if (!svg) {
                            console.warn('No SVG found in diagram', index);
                            return;
                        }
                        
                        // Check if controls already exist
                        if (container.querySelector('.diagram-zoom-controls')) {
                            return;
                        }
                        
                        let scale = 1;
                        let isPanning = false;
                        let startX, startY, scrollLeft, scrollTop;
                        
                        // Wrap SVG for better zoom control
                        if (!svg.parentElement.classList.contains('svg-wrapper')) {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'svg-wrapper';
                            svg.parentNode.insertBefore(wrapper, svg);
                            wrapper.appendChild(svg);
                        }
                        
                        const wrapper = svg.parentElement;
                        
                        // Store original padding
                        const originalPadding = 30;
                        container.style.padding = originalPadding + 'px';
                        
                        // Calculate fit-to-screen scale
                        let initialScale = 1;
                        setTimeout(() => {
                            const isMobile = window.innerWidth <= 768;
                            const containerWidth = container.clientWidth - (originalPadding * 2);
                            const containerHeight = container.clientHeight - (originalPadding * 2);
                            
                            // Get actual SVG dimensions
                            const svgRect = svg.getBoundingClientRect();
                            const svgWidth = svg.scrollWidth || svgRect.width || svg.clientWidth;
                            const svgHeight = svg.scrollHeight || svgRect.height || svg.clientHeight;
                            
                            if (svgWidth > 0 && svgHeight > 0) {
                                const scaleX = containerWidth / svgWidth;
                                const scaleY = containerHeight / svgHeight;
                                initialScale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
                                
                                // On mobile, ensure minimum scale for readability
                                if (isMobile && initialScale < 0.3) {
                                    initialScale = 0.3;
                                }
                                
                                scale = initialScale;
                                updateZoom(scale, false);
                                
                                // Center the diagram after initial zoom
                                setTimeout(() => {
                                    const maxScrollLeft = container.scrollWidth - container.clientWidth;
                                    const maxScrollTop = container.scrollHeight - container.clientHeight;
                                    container.scrollLeft = Math.max(0, maxScrollLeft / 2);
                                    container.scrollTop = Math.max(0, maxScrollTop / 2);
                                }, 100);
                            }
                        }, 200);
                        
                        // Create zoom controls
                        const controls = document.createElement('div');
                        controls.className = 'diagram-zoom-controls';
                        controls.innerHTML = `
                            <button class="zoom-btn zoom-in" title="Zoom In">+</button>
                            <button class="zoom-btn zoom-reset" title="Reset Zoom">‚ü≤</button>
                            <button class="zoom-btn zoom-out" title="Zoom Out">‚àí</button>
                        `;
                        container.style.position = 'relative';
                        container.insertBefore(controls, container.firstChild);
                        
                        // Zoom functions with smoothing and overflow handling
                        function updateZoom(newScale, smooth = false) {
                            scale = Math.max(0.5, Math.min(3, newScale));
                            
                            if (wrapper.classList.contains('svg-wrapper')) {
                                // Apply transition only for button clicks, not for continuous gestures
                                if (smooth) {
                                    wrapper.style.transition = 'transform 0.2s ease';
                                } else {
                                    wrapper.style.transition = 'none';
                                }
                                
                                // Apply scale transform - the wrapper padding will create space
                                wrapper.style.transform = `scale(${scale})`;
                                wrapper.style.transformOrigin = 'center center';
                            } else {
                                svg.style.transform = `scale(${scale})`;
                            }
                        }
                    
                    // Button controls with smooth transitions
                    controls.querySelector('.zoom-in').addEventListener('click', (e) => {
                        e.stopPropagation();
                        updateZoom(scale + 0.2, true);
                    });
                    
                    controls.querySelector('.zoom-out').addEventListener('click', (e) => {
                        e.stopPropagation();
                        updateZoom(scale - 0.2, true);
                    });
                    
                    controls.querySelector('.zoom-reset').addEventListener('click', (e) => {
                        e.stopPropagation();
                        updateZoom(initialScale, true);
                        // Reset to bottom right position
                        setTimeout(() => {
                            container.scrollLeft = container.scrollWidth - container.clientWidth;
                            container.scrollTop = container.scrollHeight - container.clientHeight;
                        }, 250);
                    });
                    
                    // Mouse wheel zoom with throttling
                    let wheelTimeout;
                    container.addEventListener('wheel', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const delta = e.deltaY > 0 ? -0.05 : 0.05;
                            
                            clearTimeout(wheelTimeout);
                            updateZoom(scale + delta, false);
                            
                            wheelTimeout = setTimeout(() => {
                                // Final adjustment after wheel stops
                                updateZoom(scale, false);
                            }, 100);
                        }
                    }, { passive: false });
                    
                    // Pan with mouse drag
                    container.addEventListener('mousedown', (e) => {
                        if (e.target.closest('.diagram-zoom-controls')) return;
                        isPanning = true;
                        startX = e.pageX - container.offsetLeft;
                        startY = e.pageY - container.offsetTop;
                        scrollLeft = container.scrollLeft;
                        scrollTop = container.scrollTop;
                    });
                    
                    container.addEventListener('mouseleave', () => {
                        isPanning = false;
                    });
                    
                    container.addEventListener('mouseup', () => {
                        isPanning = false;
                    });
                    
                    container.addEventListener('mousemove', (e) => {
                        if (!isPanning) return;
                        e.preventDefault();
                        const x = e.pageX - container.offsetLeft;
                        const y = e.pageY - container.offsetTop;
                        const walkX = (x - startX) * 1.5;
                        const walkY = (y - startY) * 1.5;
                        container.scrollLeft = scrollLeft - walkX;
                        container.scrollTop = scrollTop - walkY;
                    });
                    
                    // Touch support for mobile pinch zoom and pan
                    let touchStartDistance = 0;
                    let touchStartScale = 1;
                    let touchStartX = 0;
                    let touchStartY = 0;
                    let isTouchPanning = false;
                    let touchPanStartX = 0;
                    let touchPanStartY = 0;
                    let touchScrollLeft = 0;
                    let touchScrollTop = 0;
                    
                    container.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 2) {
                            // Two finger pinch zoom
                            e.preventDefault();
                            e.stopPropagation();
                            
                            touchStartDistance = Math.hypot(
                                e.touches[0].pageX - e.touches[1].pageX,
                                e.touches[0].pageY - e.touches[1].pageY
                            );
                            touchStartScale = scale;
                            
                            // Calculate touch center for zoom origin
                            touchStartX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
                            touchStartY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
                            isTouchPanning = false;
                        } else if (e.touches.length === 1) {
                            // Single finger pan (only when zoomed)
                            if (scale > initialScale * 1.1) {
                                isTouchPanning = true;
                                touchPanStartX = e.touches[0].pageX;
                                touchPanStartY = e.touches[0].pageY;
                                touchScrollLeft = container.scrollLeft;
                                touchScrollTop = container.scrollTop;
                            }
                        }
                    }, { passive: false });
                    
                    container.addEventListener('touchmove', (e) => {
                        if (e.touches.length === 2) {
                            // Two finger pinch zoom
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const touchDistance = Math.hypot(
                                e.touches[0].pageX - e.touches[1].pageX,
                                e.touches[0].pageY - e.touches[1].pageY
                            );
                            
                            const newScale = touchStartScale * (touchDistance / touchStartDistance);
                            updateZoom(newScale);
                        } else if (e.touches.length === 1 && isTouchPanning) {
                            // Single finger pan
                            e.preventDefault();
                            
                            const deltaX = touchPanStartX - e.touches[0].pageX;
                            const deltaY = touchPanStartY - e.touches[0].pageY;
                            
                            container.scrollLeft = touchScrollLeft + deltaX;
                            container.scrollTop = touchScrollTop + deltaY;
                        }
                    }, { passive: false });
                    
                    container.addEventListener('touchend', (e) => {
                        if (e.touches.length < 2) {
                            touchStartDistance = 0;
                        }
                        if (e.touches.length === 0) {
                            isTouchPanning = false;
                        }
                    }, { passive: false });
                    }, index * 100); // Stagger initialization for complex diagrams
                });
            }, 800); // Increased timeout to ensure all diagrams are rendered
        });
        
    </script>
    <script>
        let allData = [];
        let historicalData = [];
        let forecastData = [];
        let myChart = null;
        
        // Load and parse CSV data
        async function loadData() {
            try {
                console.log('Loading CSV from:', window.location.href);
                console.log('Attempting to fetch: monkeypox_fitted_prediction.csv');
                
                const response = await fetch('monkeypox_fitted_prediction.csv');
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log('CSV loaded, length:', csvText.length, 'bytes');
                const lines = csvText.trim().split('\n');
                console.log('CSV lines:', lines.length);
                
                // Parse CSV
                const headers = lines[0].split(',');
                allData = lines.slice(1).map(line => {
                    const values = line.split(',');
                    return {
                        date: values[0],
                        S_h: parseFloat(values[1]),
                        E_h: parseFloat(values[2]),
                        I_h: parseFloat(values[3]),
                        Q_h: parseFloat(values[4]),
                        R_h: parseFloat(values[5]),
                        S_r: parseFloat(values[6]),
                        E_r: parseFloat(values[7]),
                        I_r: parseFloat(values[8]),
                        Total_Infected_h: parseFloat(values[9]),
                        observed: parseFloat(values[10]) || 0,
                        ma7: parseFloat(values[11]) || 0,
                        ma21: parseFloat(values[12]) || 0,
                        forecast_21d: parseFloat(values[13]) || 0
                    };
                });
                
                // Load forecast data
                const forecastResponse = await fetch('monkeypox_prediction.csv');
                if (forecastResponse.ok) {
                    const forecastText = await forecastResponse.text();
                    const forecastLines = forecastText.trim().split('\n');
                    const forecastData = forecastLines.slice(1).map(line => {
                        const values = line.split(',');
                        return {
                            date: values[0],
                            S_h: parseFloat(values[1]),
                            E_h: parseFloat(values[2]),
                            I_h: parseFloat(values[3]),
                            Q_h: parseFloat(values[4]),
                            R_h: parseFloat(values[5]),
                            S_r: parseFloat(values[6]),
                            E_r: parseFloat(values[7]),
                            I_r: parseFloat(values[8]),
                            Total_Infected_h: parseFloat(values[9]),
                            observed: 0,
                            ma7: 0,
                            ma21: 0,
                            isForecast: true
                        };
                    });
                    // Append forecast to main data
                    allData = allData.concat(forecastData);
                    console.log('Forecast loaded, total records:', allData.length);
                }
                
                // Populate global historical and forecast data
                historicalData = allData.filter(d => !d.isForecast);
                forecastData = allData.filter(d => d.isForecast);
                
                console.log('Data parsed successfully, records:', allData.length);
                initializeChart();
                updateStats();
                
            } catch (error) {
                console.error('Error loading data:', error);
                console.error('Error stack:', error.stack);
                document.querySelector('.chart-container').innerHTML = 
                    `<div class="loading">‚ùå Error loading data: ${error.message}<br><br>
                    <strong>Troubleshooting:</strong><br>
                    ‚Ä¢ Check browser console (F12) for details<br>
                    ‚Ä¢ Ensure monkeypox_fitted_prediction.csv is in the same directory<br>
                    ‚Ä¢ On GitHub Pages: verify CSV file is committed and pushed<br>
                    ‚Ä¢ Current URL: ${window.location.href}</div>`;
            }
        }
        
        function initializeChart() {
            const ctx = document.getElementById('seirChart').getContext('2d');
            const isMobile = window.innerWidth <= 768;
            
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: allData.map(d => d.date),
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    elements: {
                        line: {
                            borderWidth: isMobile ? 1 : 2,
                            tension: 0.4
                        },
                        point: {
                            radius: isMobile ? 0 : 1,
                            hitRadius: isMobile ? 5 : 4,
                            hoverRadius: isMobile ? 3 : 4
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: isMobile ? 10 : 13,
                                    weight: 'bold'
                                },
                                padding: isMobile ? 8 : 15,
                                boxWidth: isMobile ? 30 : 40,
                                usePointStyle: isMobile
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: isMobile ? 8 : 12,
                            titleFont: { size: isMobile ? 11 : 14 },
                            bodyFont: { size: isMobile ? 10 : 13 }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: isMobile ? 11 : 14, weight: 'bold' }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: isMobile ? 9 : 11 }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Cases / Population',
                                font: { size: isMobile ? 11 : 14, weight: 'bold' }
                            },
                            ticks: {
                                font: { size: isMobile ? 9 : 11 }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
            
            changeView();
        }
        
        function updateScale() {
            const scale = document.getElementById('scaleSelect').value;
            
            if (scale === 'log') {
                myChart.options.scales.y.type = 'logarithmic';
                myChart.options.scales.y.min = 0.1;
                myChart.options.scales.y.ticks = {
                    callback: function(value, index, values) {
                        if (value === 0.1 || value === 1 || value === 10 || 
                            value === 100 || value === 1000 || value === 10000 || 
                            value === 100000 || value === 1000000) {
                            return value.toLocaleString();
                        }
                        return null;
                    }
                };
            } else {
                myChart.options.scales.y.type = 'linear';
                delete myChart.options.scales.y.min;
                myChart.options.scales.y.ticks = {};
            }
            
            myChart.update();
        }
        
        function changeView() {
            const view = document.getElementById('viewSelect').value;
            
            if (view === 'comparison') {
                // Use global historical and forecast data (already filtered)
                const lastHistorical = historicalData[historicalData.length - 1];
                
                myChart.data.datasets = [
                    {
                        label: 'Observed Cases',
                        data: allData.map(d => d.observed),
                        borderColor: '#dc3545',
                        backgroundColor: '#dc3545',
                        pointRadius: 2,
                        pointHoverRadius: 5,
                        pointStyle: 'circle',
                        showLine: false,
                        tension: 0
                    },
                    {
                        label: '7-Day Moving Average',
                        data: historicalData.map(d => d.ma7),
                        borderColor: '#fd7e14',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: '21-Day Moving Average',
                        data: historicalData.map(d => d.ma21),
                        borderColor: '#ffc107',
                        backgroundColor: 'transparent',
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 3,
                        tension: 0.4
                    },
                    {
                        label: 'Model Prediction',
                        data: historicalData.map(d => d.Total_Infected_h),
                        borderColor: '#007bff',
                        backgroundColor: 'transparent',
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 3,
                        tension: 0.4
                    },
                    {
                        label: '21-Day Forecast',
                        data: (() => {
                            // Shift forecast values 21 days into the future
                            const forecastArray = new Array(allData.length).fill(null);
                            historicalData.forEach((d, i) => {
                                if (d.forecast_21d && d.forecast_21d > 0 && i + 21 < allData.length) {
                                    forecastArray[i + 21] = d.forecast_21d;
                                }
                            });
                            // Add future forecast data
                            forecastData.forEach((d, i) => {
                                const idx = historicalData.length + i;
                                if (idx < forecastArray.length) {
                                    forecastArray[idx] = d.Total_Infected_h;
                                }
                            });
                            return forecastArray;
                        })(),
                        borderColor: '#6f42c1',
                        backgroundColor: 'transparent',
                        borderDash: [10, 5],
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 2,
                        tension: 0.4
                    }
                ];
            } else if (view === 'human') {
                myChart.data.datasets = [
                    {
                        label: 'Susceptible (S_h)',
                        data: allData.map(d => d.S_h),
                        borderColor: '#28a745',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Exposed (E_h)',
                        data: allData.map(d => d.E_h),
                        borderColor: '#ffc107',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Infectious (I_h)',
                        data: allData.map(d => d.I_h),
                        borderColor: '#dc3545',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Quarantined (Q_h)',
                        data: allData.map(d => d.Q_h),
                        borderColor: '#fd7e14',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Recovered (R_h)',
                        data: allData.map(d => d.R_h),
                        borderColor: '#6f42c1',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    }
                ];
            } else if (view === 'rodent') {
                myChart.data.datasets = [
                    {
                        label: 'Susceptible Rodents (S_r)',
                        data: allData.map(d => d.S_r),
                        borderColor: '#20c997',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Exposed Rodents (E_r)',
                        data: allData.map(d => d.E_r),
                        borderColor: '#17a2b8',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Infectious Rodents (I_r)',
                        data: allData.map(d => d.I_r),
                        borderColor: '#e83e8c',
                        backgroundColor: 'transparent',
                        fill: false,
                        borderWidth: 2,
                        tension: 0.4
                    }
                ];
            }
            
            // Apply year filter after changing view
            filterData();
        }
        
        function filterData() {
            const year = document.getElementById('yearSelect').value;
            
            let filteredData = allData;
            let filteredHistorical = historicalData;
            let filteredForecast = forecastData;
            
            if (year !== 'all') {
                filteredData = allData.filter(d => d.date.includes(year));
                filteredHistorical = historicalData.filter(d => d.date.includes(year));
                filteredForecast = forecastData.filter(d => d.date.includes(year));
            }
            
            myChart.data.labels = filteredData.map(d => d.date);
            
            const view = document.getElementById('viewSelect').value;
            if (view === 'comparison') {
                myChart.data.datasets[0].data = filteredData.map(d => d.observed);
                myChart.data.datasets[1].data = filteredHistorical.map(d => d.ma7);
                myChart.data.datasets[2].data = filteredHistorical.map(d => d.ma21);
                myChart.data.datasets[3].data = filteredHistorical.map(d => d.Total_Infected_h);
                
                // Shift forecast values 21 days into the future using date matching
                const forecastArray = new Array(filteredData.length).fill(null);
                
                // For each historical point with forecast, find the target date 21 days ahead
                historicalData.forEach(histPoint => {
                    if (histPoint.forecast_21d && histPoint.forecast_21d > 0) {
                        // Find this point's index in all data
                        const sourceIdx = allData.findIndex(d => d.date === histPoint.date);
                        if (sourceIdx >= 0 && sourceIdx + 21 < allData.length) {
                            const targetDate = allData[sourceIdx + 21].date;
                            // Find this target date in filtered data
                            const targetIdx = filteredData.findIndex(d => d.date === targetDate);
                            if (targetIdx >= 0) {
                                forecastArray[targetIdx] = histPoint.forecast_21d;
                            }
                        }
                    }
                });
                
                // Add future forecast data
                filteredForecast.forEach((d, i) => {
                    const idx = filteredHistorical.length + i;
                    if (idx < forecastArray.length) {
                        forecastArray[idx] = d.Total_Infected_h;
                    }
                });
                myChart.data.datasets[4].data = forecastArray;
            } else if (view === 'human') {
                myChart.data.datasets[0].data = filteredData.map(d => d.S_h);
                myChart.data.datasets[1].data = filteredData.map(d => d.E_h);
                myChart.data.datasets[2].data = filteredData.map(d => d.I_h);
                myChart.data.datasets[3].data = filteredData.map(d => d.Q_h);
                myChart.data.datasets[4].data = filteredData.map(d => d.R_h);
            } else if (view === 'rodent') {
                myChart.data.datasets[0].data = filteredData.map(d => d.S_r);
                myChart.data.datasets[1].data = filteredData.map(d => d.E_r);
                myChart.data.datasets[2].data = filteredData.map(d => d.I_r);
            }
            
            // Auto-adjust Y-axis scale based on filtered data
            const allValues = [];
            myChart.data.datasets.forEach(dataset => {
                dataset.data.forEach(val => {
                    if (val != null && val > 0) allValues.push(val);
                });
            });
            
            if (allValues.length > 0) {
                const maxVal = Math.max(...allValues);
                const minVal = Math.min(...allValues);
                
                // Reset scale to fit the filtered data
                if (myChart.options.scales.y.type === 'logarithmic') {
                    myChart.options.scales.y.min = Math.max(0.01, minVal * 0.5);
                    myChart.options.scales.y.max = maxVal * 2;
                } else {
                    myChart.options.scales.y.min = undefined;
                    myChart.options.scales.y.max = undefined;
                    myChart.options.scales.y.beginAtZero = true;
                }
            }
            
            myChart.update();
            updateStats(filteredData);
        }
        
        function updateStats(data = allData) {
            const totalObserved = data.reduce((sum, d) => sum + d.observed, 0);
            const maxObserved = Math.max(...data.map(d => d.observed));
            const maxPredicted = Math.max(...data.map(d => d.Total_Infected_h));
            const finalSusceptible = data[data.length - 1].S_h;
            const finalRecovered = data[data.length - 1].R_h;
            
            const statsContainer = document.getElementById('statsContainer');
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Observed Cases</div>
                    <div class="stat-value">${Math.round(totalObserved).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Observed</div>
                    <div class="stat-value">${Math.round(maxObserved).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Predicted</div>
                    <div class="stat-value">${Math.round(maxPredicted).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Susceptible (S_h)</div>
                    <div class="stat-value">${Math.round(finalSusceptible).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Recovered (R_h)</div>
                    <div class="stat-value">${Math.round(finalRecovered).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Data Points</div>
                    <div class="stat-value">${data.length}</div>
                </div>
            `;
        }
        
        // Load data on page load
        loadData();
        
        // Render KaTeX math expressions
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

    <div class="references-section">
        <h2>üìö References</h2>
        <ol class="references-list">
            <li>
                Md. Rasel, M. S. H. Hawlader, et al., "A Mathematical Model for Monkeypox Transmission," 
                <em>Symmetry</em> 14(12):2545, 2022. 
                <a href="https://www.mdpi.com/2073-8994/14/12/2545#symmetry-14-02545-t001" target="_blank" rel="noopener noreferrer">
                    https://www.mdpi.com/2073-8994/14/12/2545
                </a>
            </li>
            <li>
                Victoria Department of Health, "Mpox (monkeypox)," 2023 guidance. 
                <a href="https://www.health.vic.gov.au/infectious-diseases/mpox-monkeypox" target="_blank" rel="noopener noreferrer">
                    https://www.health.vic.gov.au/infectious-diseases/mpox-monkeypox
                </a>
            </li>
            <li>
                Centers for Disease Control and Prevention, "Mpox (monkeypox) Data and Statistics." 
                <a href="https://www.cdc.gov/monkeypox/data-research/cases/index.html" target="_blank" rel="noopener noreferrer">
                    https://www.cdc.gov/monkeypox/data-research/cases/index.html
                </a>
            </li>
        </ol>
    </div>

    <footer class="footer">
        <p>¬© 2025 Monkeypox SEIQR-SEIR Model | Two-Population Epidemiological Model</p>
        <p>Source code: <a href="https://github.com/minhlol/approximationthingies" target="_blank" rel="noopener noreferrer">github.com/minhlol/approximationthingies</a></p>
    </footer>
</body>
</html>
