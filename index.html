<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monkeypox SEIR Model Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ğŸ¦  Monkeypox SEIR Model Visualization</h1>
        <div class="subtitle">Two-Population Epidemiological Model (Human-Rodent Interaction)</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="yearSelect">ğŸ“… Year:</label>
                <select id="yearSelect" onchange="filterData()">
                    <option value="all">All Years</option>
                    <option value="2022">2022</option>
                    <option value="2023">2023</option>
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                </select>
            </div>
            <div class="control-group">
                <label for="viewSelect">ğŸ“Š View:</label>
                <select id="viewSelect" onchange="changeView()">
                    <option value="comparison">Model vs Observed</option>
                    <option value="human">Human Compartments</option>
                    <option value="rodent">Rodent Compartments</option>
                </select>
            </div>
            <div class="control-group">
                <label for="scaleSelect">ğŸ“ Y-Scale:</label>
                <select id="scaleSelect" onchange="updateScale()">
                    <option value="linear">Linear</option>
                    <option value="log">Logarithmic</option>
                </select>
            </div>
        </div>
        
        <div class="chart-container">
            <canvas id="seirChart"></canvas>
        </div>
        
        <div class="stats" id="statsContainer"></div>
        
        <div class="architecture-section">
            <h2>ğŸ“ Model Architecture & Flow</h2>
            
            <h3>Model Equations</h3>
            
            <h4 style="color: #555; font-size: 1.2em; margin-top: 20px;">Human Compartments (SEIQR)</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0;">
                <p style="margin-bottom: 10px;">Force of infection:</p>
                <p style="font-size: 1.1em; margin: 10px 0;">$$\lambda_h = \frac{(\beta_1 \cdot I_r + \beta_2 \cdot I_h) \cdot S_h}{N_h}$$</p>
                
                <p style="margin: 20px 0 10px 0;">Differential equations:</p>
                <div style="font-size: 1.1em; line-height: 2.2;">
                    $$\frac{dS_h}{dt} = \theta_h - \lambda_h - \mu_h \cdot S_h + \phi \cdot Q_h$$
                    $$\frac{dE_h}{dt} = \lambda_h - (\alpha_1 + \alpha_2 + \mu_h) \cdot E_h$$
                    $$\frac{dI_h}{dt} = \alpha_1 \cdot E_h - (\mu_h + \delta_h + \nu) \cdot I_h$$
                    $$\frac{dQ_h}{dt} = \alpha_2 \cdot E_h - (\phi + \tau + \delta_h + \mu_h) \cdot Q_h$$
                    $$\frac{dR_h}{dt} = \nu \cdot I_h + \tau \cdot Q_h - \mu_h \cdot R_h$$
                </div>
            </div>
            
            <h4 style="color: #555; font-size: 1.2em; margin-top: 30px;">Rodent Compartments (SEIR)</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0;">
                <p style="margin-bottom: 10px;">Force of infection:</p>
                <p style="font-size: 1.1em; margin: 10px 0;">$$\lambda_r = \frac{\beta_3 \cdot S_r \cdot I_r}{N_r}$$</p>
                
                <p style="margin: 20px 0 10px 0;">Differential equations:</p>
                <div style="font-size: 1.1em; line-height: 2.2;">
                    $$\frac{dS_r}{dt} = \theta_r - \lambda_r - \mu_r \cdot S_r + \text{immigration}$$
                    $$\frac{dE_r}{dt} = \lambda_r - (\mu_r + \alpha_3) \cdot E_r + \text{replenishment}$$
                    $$\frac{dI_r}{dt} = \alpha_3 \cdot E_r - (\mu_r + \delta_r) \cdot I_r + \text{replenishment}$$
                </div>
                
                <p style="margin: 20px 0 10px 0; font-size: 0.95em;">Where:</p>
                <div style="font-size: 1em; line-height: 1.8; padding-left: 20px;">
                    $$\text{immigration} = (N_r - N_{r,\text{current}}) \times 0.001$$
                    $$\text{replenishment} = 0.05 \times (\text{target} - \text{current}) \text{ if } I_r < 50\% \text{ target}$$
                </div>
            </div>
            
            <h4 style="color: #555; font-size: 1.2em; margin-top: 30px;">Numerical Integration (RK4)</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0 40px 0;">
                <div style="font-size: 1.1em; line-height: 2.2;">
                    $$k_1 = f(t, y)$$
                    $$k_2 = f(t + \frac{dt}{2}, y + k_1 \cdot \frac{dt}{2})$$
                    $$k_3 = f(t + \frac{dt}{2}, y + k_2 \cdot \frac{dt}{2})$$
                    $$k_4 = f(t + dt, y + k_3 \cdot dt)$$
                    $$y_{n+1} = y_n + \frac{k_1 + 2k_2 + 2k_3 + k_4}{6} \cdot dt$$
                </div>
                <p style="margin-top: 15px; font-size: 0.95em;">Steps per day: 10 (dt = 0.1 day)</p>
            </div>
            
            <h3>System Overview</h3>
            <div class="diagram-description">
                Complete pipeline showing data flow through processing stages to output generation.
            </div>
            <div class="mermaid">
graph TB
    Start(["ğŸš€ Start"])
    
    subgraph Input[" ğŸ“¥ Data Input "]
        direction TB
        A1["Load Data<br/>observed_data.csv"]
        A2["Moving Averages<br/>MA7 & MA21"]
        A3["Outbreak Detection<br/>MA21 > 5"]
        
        A1 --> A2
        A2 --> A3
    end
    
    subgraph Model[" ğŸ§¬ Three-Stage Modeling "]
        direction TB
        B1["ğŸ“ˆ Stage 1<br/>Exponential Smoothing"]
        B2["ğŸ‘¥ Stage 2<br/>Human SEIQR"]
        B3["ğŸ€ Stage 3<br/>Rodent SEIR"]
        B4["ğŸ“Š Analysis<br/>RMSE & Validation"]
        
        B1 --> B2
        B2 --> B3
        B3 --> B4
    end
    
    subgraph Forecast[" ğŸ”® Forecasting "]
        direction TB
        C1["Generate Predictions<br/>21-day windows"]
        C2["Validation Check<br/>Trend analysis"]
        
        C1 --> C2
    end
    
    subgraph Output[" ğŸ’¾ Output "]
        direction TB
        D1["fitted_prediction.csv"]
        D2["prediction.csv"]
        D3["index.html"]
        
        D1 --> D3
        D2 --> D3
    end
    
    Start --> Input
    Input --> Model
    Model --> Forecast
    Forecast --> Output
    Output --> End(["âœ… Complete"])
    
    C2 -.->|Refine| B3
    
    style Input fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style Model fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Forecast fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style Output fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style Start fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style End fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
            </div>
            
            <h3>Three-Stage Model Detail</h3>
            <div class="diagram-description">
                Sequential transformation from raw observations through human epidemiology to zoonotic reservoir dynamics.
            </div>
            <div class="mermaid">
graph LR
    subgraph S1[" ğŸ“ˆ Stage 1: Data Smoothing "]
        direction TB
        Raw["ğŸ“Š Raw Cases<br/>Daily observations"]
        Raw --> MA21["ğŸ“‰ MA21<br/>21-day window"]
        MA21 --> Smooth["ğŸ¯ Exponential Smooth<br/>Î±=0.25 blend factor<br/>Reduces noise"]
    end
    
    subgraph S2[" ğŸ‘¥ Stage 2: Human SEIQR "]
        direction TB
        SplitIQ["ğŸ”€ Infectious Split<br/>I_h + Q_h from prediction"]
        SplitIQ --> FlowE["â¬…ï¸ Backtrack E_h<br/>Using Î±â‚ and Î±â‚‚ rates"]
        FlowE --> CalcR["â¡ï¸ Accumulate R_h<br/>Recovery Î½ and Ï„ rates"]
        CalcR --> CalcS["ğŸ”¢ Derive S_h<br/>Closure: N_h - E - I - Q - R"]
    end
    
    subgraph S3[" ğŸ€ Stage 3: Rodent SEIR "]
        direction TB
        Init["ğŸ² Initialize<br/>S_r, E_r, I_r states"]
        Init --> RK4["âš™ï¸ RK4 Integration<br/>10 steps per day<br/>Cross-species coupling"]
        RK4 --> Maintain["â™»ï¸ Homeostasis<br/>Endemic replenishment<br/>Target I_r = 1.5%"]
    end
    
    S1 --> S2
    S2 --> S3
    
    style S1 fill:#e1f5ff,stroke:#0077cc,stroke-width:2px
    style S2 fill:#fff4e1,stroke:#ff9900,stroke-width:2px
    style S3 fill:#ffe1f5,stroke:#cc0077,stroke-width:2px
            </div>
            
            <h3>SEIQR-SEIR Compartmental Structure</h3>
            <div class="diagram-description">
                Two-population epidemic model with human SEIQR compartments and rodent SEIR reservoir. Cross-species transmission pathways shown with dashed arrows.
            </div>
            <div class="mermaid">
graph TB
    subgraph Human[" ğŸ‘¥ Human Population: SEIQR Model "]
        direction LR
        Sh["<b>S_h</b><br/>Susceptible<br/>Healthy population"]
        Eh["<b>E_h</b><br/>Exposed<br/>Incubating virus"]
        Ih["<b>I_h</b><br/>Infectious<br/>Undetected cases"]
        Qh["<b>Q_h</b><br/>Quarantined<br/>Isolated cases"]
        Rh["<b>R_h</b><br/>Recovered<br/>Immune"]
        
        Sh -->|Î»_h infection| Eh
        Eh -->|Î±â‚ progression| Ih
        Eh -->|Î±â‚‚ detection| Qh
        Ih -->|Î½ recovery| Rh
        Qh -->|Ï„ recovery| Rh
        Qh -->|Ï† release| Sh
    end
    
    subgraph Rodent[" ğŸ€ Rodent Reservoir: SEIR Model "]
        direction LR
        Sr["<b>S_r</b><br/>Susceptible<br/>Healthy rodents"]
        Er["<b>E_r</b><br/>Exposed<br/>Incubating"]
        Ir["<b>I_r</b><br/>Infectious<br/>Viral shedding"]
        
        Sr -->|Î»_r infection| Er
        Er -->|Î±â‚ƒ progression| Ir
        Sr -.->|Immigration| Sr
        Ir -.->|Replenishment| Ir
    end
    
    Ir ==>|Î²â‚ spillover<br/>Zoonotic transmission| Sh
    Ih ==>|Î²â‚‚ transmission<br/>Human-to-human| Sh
    
    style Human fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style Rodent fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style Sh fill:#c8e6c9
    style Eh fill:#fff9c4
    style Ih fill:#ffccbc
    style Qh fill:#ff8a65
    style Rh fill:#b39ddb
    style Sr fill:#c8e6c9
    style Er fill:#fff9c4
    style Ir fill:#ffccbc
            </div>
            
            <h3>21-Day Forecast Generation</h3>
            <div class="diagram-description">
                Adaptive forecasting algorithm that selects between trajectory-based and mechanistic predictions based on epidemic phase.
            </div>
            <div class="mermaid">
graph TB
    Start(["ğŸ” For Each Day<br/>in Historical Data"])
    Start --> Trend{"ğŸ“Š Analyze 7-Day Trend<br/>Growth Rate"}
    
    Trend -->|"ğŸ“ˆ Trend â‰¥ -2<br/>Growth/Stable"| PathA["ğŸ¯ Trajectory Method<br/>High confidence in model"]
    Trend -->|"ğŸ“‰ Trend < -2<br/>Rapid Decline"| PathB["âš™ï¸ Mechanistic Method<br/>SEIQR-SEIR dynamics"]
    
    PathA --> Lookup["ğŸ” Lookup Future<br/>Model prediction at day+21"]
    Lookup --> Blend["ğŸ¨ Blend Values<br/>90% future + 10% current<br/>Smooth transition"]
    Blend --> Output
    
    PathB --> RodentCheck{"ğŸ€ Check Reservoir<br/>I_r > 0.01?"}
    RodentCheck -->|"âœ… Yes<br/>Active reservoir"| FullSim["ğŸ”¬ Full Two-Population<br/>With Î²â‚ spillover term<br/>Cross-species coupling"]
    RodentCheck -->|"âŒ No<br/>Negligible reservoir"| SimpleSim["ğŸ‘¥ Human-Only Model<br/>No zoonotic forcing<br/>Epidemic fadeout"]
    
    FullSim --> Integrate["âš™ï¸ RK4 Integration<br/>21 days Ã— 10 steps/day<br/>Homeostasis maintained"]
    SimpleSim --> Integrate
    Integrate --> Output
    
    Output["ğŸ’¾ Store Forecast<br/>at day+21 index"]
    Output --> Continue{"â“ More Days?"}
    Continue -->|"Yes"| Start
    Continue -->|"No"| Done(["âœ… Forecasting Complete<br/>All points processed"])
    
    style PathA fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style PathB fill:#ffccbc,stroke:#d84315,stroke-width:2px
    style FullSim fill:#fff9c4
    style SimpleSim fill:#e1bee7
    style Integrate fill:#b3e5fc
    style Start fill:#f0f0f0
    style Done fill:#c8e6c9
            </div>
            
            <h3>Key Parameters</h3>
            <div class="diagram-description">
                Parameter dependencies and relationships showing how transmission, progression, and control rates interact within the two-population model.
            </div>
            <div class="mermaid">
graph TB
    subgraph Pop[" ğŸ“Š Population Structure "]
        NH["<b>N_h</b> = 1,000,000<br/>Human population<br/>Determines Î»_h denominator"]
        NR["<b>N_r</b> = 100,000<br/>Rodent population<br/>Determines Î»_r denominator"]
        Target["<b>Target I_r</b> = 1.5%<br/>Endemic equilibrium<br/>Replenishment threshold"]
    end
    
    subgraph Trans[" ğŸ”€ Transmission Rates "]
        B1["<b>Î²â‚</b> = 0.00008/day<br/>ğŸ€â†’ğŸ‘¤ Spillover<br/>Drives zoonotic force"]
        B2["<b>Î²â‚‚</b> = 0.00012/day<br/>ğŸ‘¤â†’ğŸ‘¤ Human spread<br/>1.5Ã— stronger than Î²â‚"]
        B3["<b>Î²â‚ƒ</b> = 0.0003/day<br/>ğŸ€â†’ğŸ€ Rodent spread<br/>Maintains reservoir"]
    end
    
    subgraph FOI[" âš¡ Force of Infection "]
        LambdaH["<b>Î»_h</b> = (Î²â‚Â·I_r + Î²â‚‚Â·I_h)Â·S_h/N_h<br/>Human infection pressure<br/>Two sources: rodent + human"]
        LambdaR["<b>Î»_r</b> = Î²â‚ƒÂ·S_rÂ·I_r/N_r<br/>Rodent infection pressure<br/>Frequency-dependent"]
    end
    
    subgraph Prog[" â±ï¸ Disease Progression "]
        A1["<b>Î±â‚</b> = 0.143/day<br/>E_h â†’ I_h pathway<br/>~7 days to symptoms"]
        A2["<b>Î±â‚‚</b> = 0.067/day<br/>E_h â†’ Q_h pathway<br/>~15 days to detection"]
        A3["<b>Î±â‚ƒ</b> = 0.20/day<br/>E_r â†’ I_r pathway<br/>~5 days (faster in rodents)"]
        Branching["Branching: Î±â‚ + Î±â‚‚<br/>Detection fraction: Î±â‚‚/(Î±â‚+Î±â‚‚)â‰ˆ32%"]
    end
    
    subgraph Rec[" ğŸ¥ Recovery & Control "]
        Nu["<b>Î½</b> = 0.067/day<br/>I_h â†’ R_h recovery<br/>~15 days untreated"]
        Tau["<b>Ï„</b> = 0.143/day<br/>Q_h â†’ R_h recovery<br/>~7 days (2Ã— faster)"]
        Phi["<b>Ï†</b> = 0.20/day<br/>Q_h â†’ S_h release<br/>False positive pathway"]
        IsolationBenefit["Isolation effect:<br/>Ï„ > Î½ (faster recovery)<br/>Reduces transmission"]
    end
    
    subgraph Death[" âš ï¸ Mortality & Turnover "]
        DH["<b>Î´_h</b> disease CFR"]
        DR["<b>Î´_r</b> rodent disease death"]
        MuH["<b>Î¼_h</b> natural death"]
        MuR["<b>Î¼_r</b> natural death"]
        ThetaH["<b>Î¸_h</b> birth/immigration<br/>Maintains N_h"]
        ThetaR["<b>Î¸_r</b> rodent birth<br/>Maintains N_r"]
    end
    
    %% Relationships between parameter groups
    NH --> LambdaH
    NR --> LambdaR
    B1 --> LambdaH
    B2 --> LambdaH
    B3 --> LambdaR
    
    LambdaH -.->|"Drives E_h"| Prog
    LambdaR -.->|"Drives E_r"| Prog
    
    A1 -.-> Nu
    A2 -.-> Tau
    A2 -.-> Phi
    
    Target -.->|"Threshold"| B3
    NR -.->|"Scale"| Target
    
    ThetaH -.-> NH
    ThetaR -.-> NR
    MuH -.-> NH
    MuR -.-> NR
    
    Branching -.->|"Splitting"| A1
    Branching -.->|"Splitting"| A2
    IsolationBenefit -.->|"Compare"| Nu
    IsolationBenefit -.->|"Compare"| Tau
    
    style Pop fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Trans fill:#ffebee,stroke:#c62828,stroke-width:3px
    style FOI fill:#e1f5fe,stroke:#01579b,stroke-width:3px
    style Prog fill:#f3e5f5,stroke:#6a1b9a,stroke-width:3px
    style Rec fill:#e8f5e9,stroke:#2e7d32,stroke-width:3px
    style Death fill:#fafafa,stroke:#616161,stroke-width:2px
    style LambdaH fill:#b3e5fc,stroke:#0277bd,stroke-width:2px
    style LambdaR fill:#b3e5fc,stroke:#0277bd,stroke-width:2px
    style Branching fill:#ce93d8,stroke:#6a1b9a,stroke-width:2px
    style IsolationBenefit fill:#a5d6a7,stroke:#2e7d32,stroke-width:2px
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid with KaTeX support
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis',
                padding: 20,
                diagramPadding: 20,
                nodeSpacing: 50,
                rankSpacing: 50
            },
            themeVariables: {
                fontSize: '18px',
                fontFamily: 'Segoe UI, Arial, sans-serif',
                edgeLabelBackground: '#ffffff',
                lineColor: '#666',
                primaryColor: '#f8f9fa',
                primaryTextColor: '#333',
                primaryBorderColor: '#666',
                secondaryColor: '#fff',
                tertiaryColor: '#f8f9fa'
            },
            katex: {
                enabled: true
            }
        });
        
        // Add zoom and pan functionality to all mermaid diagrams
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for mermaid to fully render all diagrams
            setTimeout(() => {
                const mermaidContainers = document.querySelectorAll('.mermaid');
                
                mermaidContainers.forEach((container, index) => {
                    // Wait a bit more for complex diagrams
                    setTimeout(() => {
                        const svg = container.querySelector('svg');
                        if (!svg) {
                            console.warn('No SVG found in diagram', index);
                            return;
                        }
                        
                        // Check if controls already exist
                        if (container.querySelector('.diagram-zoom-controls')) {
                            return;
                        }
                        
                        let scale = 1;
                        let isPanning = false;
                        let startX, startY, scrollLeft, scrollTop;
                        
                        // Wrap SVG for better zoom control
                        if (!svg.parentElement.classList.contains('svg-wrapper')) {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'svg-wrapper';
                            svg.parentNode.insertBefore(wrapper, svg);
                            wrapper.appendChild(svg);
                        }
                        
                        const wrapper = svg.parentElement;
                        
                        // Calculate fit-to-screen scale
                        let initialScale = 1;
                        setTimeout(() => {
                            const containerWidth = container.clientWidth - 60; // Account for padding
                            const containerHeight = container.clientHeight - 60;
                            const svgWidth = svg.scrollWidth || svg.clientWidth;
                            const svgHeight = svg.scrollHeight || svg.clientHeight;
                            
                            if (svgWidth > 0 && svgHeight > 0) {
                                const scaleX = containerWidth / svgWidth;
                                const scaleY = containerHeight / svgHeight;
                                initialScale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down
                                scale = initialScale;
                                updateZoom(scale);
                                
                                // Center the diagram after initial zoom
                                setTimeout(() => {
                                    const maxScrollLeft = container.scrollWidth - container.clientWidth;
                                    const maxScrollTop = container.scrollHeight - container.clientHeight;
                                    container.scrollLeft = Math.max(0, maxScrollLeft / 2);
                                    container.scrollTop = Math.max(0, maxScrollTop / 2);
                                }, 50);
                            }
                        }, 100);
                        
                        // Create zoom controls
                        const controls = document.createElement('div');
                        controls.className = 'diagram-zoom-controls';
                        controls.innerHTML = `
                            <button class="zoom-btn zoom-in" title="Zoom In">+</button>
                            <button class="zoom-btn zoom-reset" title="Reset Zoom">âŸ²</button>
                            <button class="zoom-btn zoom-out" title="Zoom Out">âˆ’</button>
                        `;
                        container.style.position = 'relative';
                        container.insertBefore(controls, container.firstChild);
                        
                        // Zoom functions
                        function updateZoom(newScale) {
                            scale = Math.max(0.5, Math.min(3, newScale));
                            
                            if (wrapper.classList.contains('svg-wrapper')) {
                                wrapper.style.transform = `scale(${scale})`;
                                
                                // Update wrapper size to accommodate scaled content
                                const baseWidth = svg.scrollWidth || svg.clientWidth;
                                const baseHeight = svg.scrollHeight || svg.clientHeight;
                                wrapper.style.width = (baseWidth * scale) + 'px';
                                wrapper.style.height = (baseHeight * scale) + 'px';
                                wrapper.style.margin = '0 auto';
                            } else {
                                svg.style.transform = `scale(${scale})`;
                            }
                        }
                    
                    // Button controls
                    controls.querySelector('.zoom-in').addEventListener('click', (e) => {
                        e.stopPropagation();
                        updateZoom(scale + 0.2);
                    });
                    
                    controls.querySelector('.zoom-out').addEventListener('click', (e) => {
                        e.stopPropagation();
                        updateZoom(scale - 0.2);
                    });
                    
                    controls.querySelector('.zoom-reset').addEventListener('click', (e) => {
                        e.stopPropagation();
                        updateZoom(initialScale);
                        // Reset to bottom right position
                        setTimeout(() => {
                            container.scrollLeft = container.scrollWidth - container.clientWidth;
                            container.scrollTop = container.scrollHeight - container.clientHeight;
                        }, 50);
                    });
                    
                    // Mouse wheel zoom
                    container.addEventListener('wheel', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const delta = e.deltaY > 0 ? -0.1 : 0.1;
                            updateZoom(scale + delta);
                        }
                    }, { passive: false });
                    
                    // Pan with mouse drag
                    container.addEventListener('mousedown', (e) => {
                        if (e.target.closest('.diagram-zoom-controls')) return;
                        isPanning = true;
                        startX = e.pageX - container.offsetLeft;
                        startY = e.pageY - container.offsetTop;
                        scrollLeft = container.scrollLeft;
                        scrollTop = container.scrollTop;
                    });
                    
                    container.addEventListener('mouseleave', () => {
                        isPanning = false;
                    });
                    
                    container.addEventListener('mouseup', () => {
                        isPanning = false;
                    });
                    
                    container.addEventListener('mousemove', (e) => {
                        if (!isPanning) return;
                        e.preventDefault();
                        const x = e.pageX - container.offsetLeft;
                        const y = e.pageY - container.offsetTop;
                        const walkX = (x - startX) * 1.5;
                        const walkY = (y - startY) * 1.5;
                        container.scrollLeft = scrollLeft - walkX;
                        container.scrollTop = scrollTop - walkY;
                    });
                    
                    // Touch support for mobile pinch zoom
                    let touchStartDistance = 0;
                    let touchStartScale = 1;
                    let touchStartX = 0;
                    let touchStartY = 0;
                    
                    container.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            touchStartDistance = Math.hypot(
                                e.touches[0].pageX - e.touches[1].pageX,
                                e.touches[0].pageY - e.touches[1].pageY
                            );
                            touchStartScale = scale;
                            
                            // Calculate touch center for zoom origin
                            touchStartX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
                            touchStartY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
                        }
                    }, { passive: false });
                    
                    container.addEventListener('touchmove', (e) => {
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const touchDistance = Math.hypot(
                                e.touches[0].pageX - e.touches[1].pageX,
                                e.touches[0].pageY - e.touches[1].pageY
                            );
                            
                            const newScale = touchStartScale * (touchDistance / touchStartDistance);
                            updateZoom(newScale);
                        }
                    }, { passive: false });
                    
                    container.addEventListener('touchend', (e) => {
                        if (e.touches.length < 2) {
                            touchStartDistance = 0;
                        }
                    }, { passive: false });
                    }, index * 100); // Stagger initialization for complex diagrams
                });
            }, 800); // Increased timeout to ensure all diagrams are rendered
        });
        
    </script>
    <script>
        let allData = [];
        let historicalData = [];
        let forecastData = [];
        let myChart = null;
        
        // Load and parse CSV data
        async function loadData() {
            try {
                console.log('Loading CSV from:', window.location.href);
                console.log('Attempting to fetch: monkeypox_fitted_prediction.csv');
                
                const response = await fetch('monkeypox_fitted_prediction.csv');
                console.log('Response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                console.log('CSV loaded, length:', csvText.length, 'bytes');
                const lines = csvText.trim().split('\n');
                console.log('CSV lines:', lines.length);
                
                // Parse CSV
                const headers = lines[0].split(',');
                allData = lines.slice(1).map(line => {
                    const values = line.split(',');
                    return {
                        date: values[0],
                        S_h: parseFloat(values[1]),
                        E_h: parseFloat(values[2]),
                        I_h: parseFloat(values[3]),
                        Q_h: parseFloat(values[4]),
                        R_h: parseFloat(values[5]),
                        S_r: parseFloat(values[6]),
                        E_r: parseFloat(values[7]),
                        I_r: parseFloat(values[8]),
                        Total_Infected_h: parseFloat(values[9]),
                        observed: parseFloat(values[10]) || 0,
                        ma7: parseFloat(values[11]) || 0,
                        ma21: parseFloat(values[12]) || 0,
                        forecast_90d: parseFloat(values[13]) || 0
                    };
                });
                
                // Load forecast data
                const forecastResponse = await fetch('monkeypox_prediction.csv');
                if (forecastResponse.ok) {
                    const forecastText = await forecastResponse.text();
                    const forecastLines = forecastText.trim().split('\n');
                    const forecastData = forecastLines.slice(1).map(line => {
                        const values = line.split(',');
                        return {
                            date: values[0],
                            S_h: parseFloat(values[1]),
                            E_h: parseFloat(values[2]),
                            I_h: parseFloat(values[3]),
                            Q_h: parseFloat(values[4]),
                            R_h: parseFloat(values[5]),
                            S_r: parseFloat(values[6]),
                            E_r: parseFloat(values[7]),
                            I_r: parseFloat(values[8]),
                            Total_Infected_h: parseFloat(values[9]),
                            observed: 0,
                            ma7: 0,
                            ma21: 0,
                            isForecast: true
                        };
                    });
                    // Append forecast to main data
                    allData = allData.concat(forecastData);
                    console.log('Forecast loaded, total records:', allData.length);
                }
                
                // Populate global historical and forecast data
                historicalData = allData.filter(d => !d.isForecast);
                forecastData = allData.filter(d => d.isForecast);
                
                console.log('Data parsed successfully, records:', allData.length);
                initializeChart();
                updateStats();
                
            } catch (error) {
                console.error('Error loading data:', error);
                console.error('Error stack:', error.stack);
                document.querySelector('.chart-container').innerHTML = 
                    `<div class="loading">âŒ Error loading data: ${error.message}<br><br>
                    <strong>Troubleshooting:</strong><br>
                    â€¢ Check browser console (F12) for details<br>
                    â€¢ Ensure monkeypox_fitted_prediction.csv is in the same directory<br>
                    â€¢ On GitHub Pages: verify CSV file is committed and pushed<br>
                    â€¢ Current URL: ${window.location.href}</div>`;
            }
        }
        
        function initializeChart() {
            const ctx = document.getElementById('seirChart').getContext('2d');
            
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: allData.map(d => d.date),
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 13,
                                    weight: 'bold'
                                },
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: { size: 14 },
                            bodyFont: { size: 13 }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Cases / Population',
                                font: { size: 14, weight: 'bold' }
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
            
            changeView();
        }
        
        function updateScale() {
            const scale = document.getElementById('scaleSelect').value;
            
            if (scale === 'log') {
                myChart.options.scales.y.type = 'logarithmic';
                myChart.options.scales.y.min = 0.1;
                myChart.options.scales.y.ticks = {
                    callback: function(value, index, values) {
                        if (value === 0.1 || value === 1 || value === 10 || 
                            value === 100 || value === 1000 || value === 10000 || 
                            value === 100000 || value === 1000000) {
                            return value.toLocaleString();
                        }
                        return null;
                    }
                };
            } else {
                myChart.options.scales.y.type = 'linear';
                delete myChart.options.scales.y.min;
                myChart.options.scales.y.ticks = {};
            }
            
            myChart.update();
        }
        
        function changeView() {
            const view = document.getElementById('viewSelect').value;
            
            if (view === 'comparison') {
                // Use global historical and forecast data (already filtered)
                const lastHistorical = historicalData[historicalData.length - 1];
                
                myChart.data.datasets = [
                    {
                        label: 'Observed Cases',
                        data: allData.map(d => d.observed),
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        pointRadius: 1,
                        pointHoverRadius: 4,
                        borderWidth: 1,
                        tension: 0
                    },
                    {
                        label: '7-Day Moving Average',
                        data: historicalData.map(d => d.ma7),
                        borderColor: '#fd7e14',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: '21-Day Moving Average',
                        data: historicalData.map(d => d.ma21),
                        borderColor: '#ffc107',
                        backgroundColor: 'rgba(255, 193, 7, 0.1)',
                        fill: true,
                        pointRadius: 0,
                        borderWidth: 3,
                        tension: 0.4
                    },
                    {
                        label: 'Model Prediction',
                        data: historicalData.map(d => d.Total_Infected_h),
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        fill: true,
                        pointRadius: 0,
                        borderWidth: 3,
                        tension: 0.4
                    },
                    {
                        label: '21-Day Forecast',
                        data: (() => {
                            // Shift forecast values 21 days into the future
                            const forecastArray = new Array(allData.length).fill(null);
                            historicalData.forEach((d, i) => {
                                if (d.forecast_90d && i + 21 < allData.length) {
                                    forecastArray[i + 21] = d.forecast_90d;
                                }
                            });
                            // Add future forecast data
                            forecastData.forEach((d, i) => {
                                const idx = historicalData.length + i;
                                if (idx < forecastArray.length) {
                                    forecastArray[idx] = d.Total_Infected_h;
                                }
                            });
                            return forecastArray;
                        })(),
                        borderColor: '#6f42c1',
                        backgroundColor: 'rgba(111, 66, 193, 0.1)',
                        borderDash: [10, 5],
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 2,
                        tension: 0.4
                    }
                ];
            } else if (view === 'human') {
                myChart.data.datasets = [
                    {
                        label: 'Susceptible (S_h)',
                        data: allData.map(d => d.S_h),
                        borderColor: '#28a745',
                        backgroundColor: 'rgba(40, 167, 69, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Exposed (E_h)',
                        data: allData.map(d => d.E_h),
                        borderColor: '#ffc107',
                        backgroundColor: 'rgba(255, 193, 7, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Infectious (I_h)',
                        data: allData.map(d => d.I_h),
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Quarantined (Q_h)',
                        data: allData.map(d => d.Q_h),
                        borderColor: '#fd7e14',
                        backgroundColor: 'rgba(253, 126, 20, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Recovered (R_h)',
                        data: allData.map(d => d.R_h),
                        borderColor: '#6f42c1',
                        backgroundColor: 'rgba(111, 66, 193, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    }
                ];
            } else if (view === 'rodent') {
                myChart.data.datasets = [
                    {
                        label: 'Susceptible Rodents (S_r)',
                        data: allData.map(d => d.S_r),
                        borderColor: '#20c997',
                        backgroundColor: 'rgba(32, 201, 151, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Exposed Rodents (E_r)',
                        data: allData.map(d => d.E_r),
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    },
                    {
                        label: 'Infectious Rodents (I_r)',
                        data: allData.map(d => d.I_r),
                        borderColor: '#e83e8c',
                        backgroundColor: 'rgba(232, 62, 140, 0.1)',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.4
                    }
                ];
            }
            
            myChart.update();
        }
        
        function filterData() {
            const year = document.getElementById('yearSelect').value;
            
            let filteredData = allData;
            let filteredHistorical = historicalData;
            let filteredForecast = forecastData;
            
            if (year !== 'all') {
                filteredData = allData.filter(d => d.date.includes(year));
                filteredHistorical = historicalData.filter(d => d.date.includes(year));
                filteredForecast = forecastData.filter(d => d.date.includes(year));
            }
            
            myChart.data.labels = filteredData.map(d => d.date);
            
            const view = document.getElementById('viewSelect').value;
            if (view === 'comparison') {
                myChart.data.datasets[0].data = filteredData.map(d => d.observed);
                myChart.data.datasets[1].data = filteredHistorical.map(d => d.ma7);
                myChart.data.datasets[2].data = filteredHistorical.map(d => d.ma21);
                myChart.data.datasets[3].data = filteredHistorical.map(d => d.Total_Infected_h);
                
                // Shift forecast values 21 days into the future using date matching
                const forecastArray = new Array(filteredData.length).fill(null);
                
                // For each historical point with forecast, find the target date 21 days ahead
                historicalData.forEach(histPoint => {
                    if (histPoint.forecast_90d) {
                        // Find this point's index in all data
                        const sourceIdx = allData.findIndex(d => d.date === histPoint.date);
                        if (sourceIdx >= 0 && sourceIdx + 21 < allData.length) {
                            const targetDate = allData[sourceIdx + 21].date;
                            // Find this target date in filtered data
                            const targetIdx = filteredData.findIndex(d => d.date === targetDate);
                            if (targetIdx >= 0) {
                                forecastArray[targetIdx] = histPoint.forecast_90d;
                            }
                        }
                    }
                });
                
                // Add future forecast data
                filteredForecast.forEach((d, i) => {
                    const idx = filteredHistorical.length + i;
                    if (idx < forecastArray.length) {
                        forecastArray[idx] = d.Total_Infected_h;
                    }
                });
                myChart.data.datasets[4].data = forecastArray;
            } else if (view === 'human') {
                myChart.data.datasets[0].data = filteredData.map(d => d.S_h);
                myChart.data.datasets[1].data = filteredData.map(d => d.E_h);
                myChart.data.datasets[2].data = filteredData.map(d => d.I_h);
                myChart.data.datasets[3].data = filteredData.map(d => d.Q_h);
                myChart.data.datasets[4].data = filteredData.map(d => d.R_h);
            } else if (view === 'rodent') {
                myChart.data.datasets[0].data = filteredData.map(d => d.S_r);
                myChart.data.datasets[1].data = filteredData.map(d => d.E_r);
                myChart.data.datasets[2].data = filteredData.map(d => d.I_r);
            }
            
            // Auto-adjust Y-axis scale based on filtered data
            const allValues = [];
            myChart.data.datasets.forEach(dataset => {
                dataset.data.forEach(val => {
                    if (val > 0) allValues.push(val);
                });
            });
            
            if (allValues.length > 0) {
                const maxVal = Math.max(...allValues);
                const minVal = Math.min(...allValues);
                
                // Reset scale to fit the filtered data
                if (myChart.options.scales.y.type === 'logarithmic') {
                    myChart.options.scales.y.min = Math.max(0.01, minVal * 0.5);
                    myChart.options.scales.y.max = maxVal * 2;
                } else {
                    delete myChart.options.scales.y.min;
                    myChart.options.scales.y.max = maxVal * 1.1;
                }
            }
            
            myChart.update();
            updateStats(filteredData);
        }
        
        function updateStats(data = allData) {
            const totalObserved = data.reduce((sum, d) => sum + d.observed, 0);
            const maxObserved = Math.max(...data.map(d => d.observed));
            const maxPredicted = Math.max(...data.map(d => d.Total_Infected_h));
            const finalSusceptible = data[data.length - 1].S_h;
            const finalRecovered = data[data.length - 1].R_h;
            
            const statsContainer = document.getElementById('statsContainer');
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Observed Cases</div>
                    <div class="stat-value">${Math.round(totalObserved).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Observed</div>
                    <div class="stat-value">${Math.round(maxObserved).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Predicted</div>
                    <div class="stat-value">${Math.round(maxPredicted).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Susceptible (S_h)</div>
                    <div class="stat-value">${Math.round(finalSusceptible).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Final Recovered (R_h)</div>
                    <div class="stat-value">${Math.round(finalRecovered).toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Data Points</div>
                    <div class="stat-value">${data.length}</div>
                </div>
            `;
        }
        
        // Load data on page load
        loadData();
        
        // Render KaTeX math expressions
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ],
                throwOnError: false
            });
        });
    </script>
</body>
</html>
